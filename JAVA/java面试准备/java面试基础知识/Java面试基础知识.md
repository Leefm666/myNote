# 面向对象和面向过程的区别

面向过程性能并不是比面向过程低，他们都需要分配内存，只是java半编译语言，cpu并不是直接执行二进制代码。

# java语言有哪些特点

1. 支持多线程（c++没有内置的多线程机制，必须调用操作系统的多线程功能）
2. 支持网络编程

# 关于jvm jdk和jre最详细的解答

## jvm

java虚拟机（jvm）是运行java字节码的虚拟机。不同系统的java虚拟机不同，但执行的字节码相同

## 什么是字节码，好处是什么

jvm可以理解的代码叫做字节码

![Javaç¨åºè¿è¡è¿ç¨](Java面试基础知识.assets/Java 程序运行过程.png)

.class文件到机器码这一步，jvm类加载器加载字节码文件，然后通过解释器解释执行，效率比较低

有些代码或代码块需要被调用，所以引进了jit编译器，jit属于运行时编译，当jit编译器完成第一次编译时，会将机器码和字节码保存下来，下次可直接使用。这说明了java是编译和解释共存的语言

---

HotSpot采用了惰性评估，根据二八定律，消耗大部分系统资源的只是一小部分代码，jvm会根据每次执行代码的情况来进行优化，因此执行次数越多，速度越快，java9 引进了一种新的编译模式AOT(ahead of time compilation) 他还是直接将字节码编译成机器码

## jdk和jre

jre（java运行环境）是jdk（java 开发环境）的子集。

# Oracle jdk 和open jdk 的区别

Oracle jdk 版本基于open jdk 7构建的，Oracle jdk 在open jdk的基础上面增加了新的功能，比如说

图形光栅化器，第三方字体等

### 总结

1. Oracle jdk 每6个月发一次主要版本，而且openjdk版本每三个月发布一次
2. Oracle jdk更稳定
3. 在响应性和jvm性能方面，Oracle jdk更好的性能

# java和c++的区别

1. 面向对象语言
2. java单继承接口多继承，c++支持多继承
3. 在c语言中，字符串和字符数组都会有额外的字符‘/0’来表示结束
   1. 由于java一切都是对象，会有length字段来限制字符串

# java应用程序与小程序的差别

应用程序有main方法，applet没有，因为是嵌在浏览器的页面执行，调用run（）或init（）方面启动

# 字符型常量和字符串常量的区别

1. 形式上：字符常量是单引号，字符串是双引号
2. 字符常量相当于ascll值，可以参加表达式运算，字符串代表一个地址值
3. 字符常量只占用2个字节

java的基本类型并不会随着系统的不同的变化

# 重写

发生在运行期，

1. 抛出的异常必须小于等于父，访问修饰符范围大于等于父类
2. 父类方法访问修饰符为private、final、static，子类就不能重写该方法，但static修饰的方法可再次声明

# 多态

引用变量的具体值或引用变量指的方法在运行时才确定

有两种方法实现多态

1. 多个子类对同一方法重写
2. 接口并覆盖接口同一方法（编译看左边，运行看右边）

# String StringBuffer和StringBuilder的区别，String为什么是不可变的

## 可变性

String类使用final关键字来保存字符串，private final char value【】

在java9 String类的事项改用byte数组来实现

private final byte【】 value；

而StringBuilder 与StringBuffer都是继承AbstractStringBuilder用char【】value

StringBuffer是线程安全的，因为加了同步锁

## 性能

String类每次改变，都会生成一个新的String对象

StringBuffer每次都是StringBuffer对象进行操作

StringBuilder比StringBuffer快，但不安全

总结

1. 少量使用String
2. 单线程使用StringBuilder
3. 多线程使用StringBuffer

# 在一个静态的方法内调用一个非静态成员为什么是非法的

由于静态方法可以不通过对象进行调用，因此在静态方法里，不能调用其他非静态变量，也不可以访问非静态变量成员。

#  在java中定义一个不做事且没有参数的构造方法的作用

子类在执行时，如果没有用super调用父类的构造方法，就会调用父类的空构造方法

# 接口和抽象类的区别是什么

1. 接口的方法默认是public。所有方法在接口不能有实现（java 8 开始接口方法所有方法可以有默认实现），而抽象类可以有非抽象的方法。
2. 接口中除了static、final变量，不能有其他变量，而抽象类不一定
3. 接口方法默认修饰符是public，抽象方法可以有public、protected，default这些修饰符
4. 从设计层面来看，抽象是对类的抽象，是一种模板设计，而接口对行为的抽象，是一种行为的规范

# 成员变量与局部变量的区别

1. 成员变量可以被public、private、static的修饰符修饰，而局部变量不能被访问控制符锁修饰，但成员变量和局部变量都能被final所修饰
2. 从变量在内存来看，成员变量被static修饰是属于类的，如果没有属于实例对象的。而对象存在堆中，局部变量则存在栈内中，
3. 从存活时间来看，成员变量是对象的不一部分，他随着对象的创建而存在，而局部变量随着调用而自动消失
4. 成员变梁会自动赋值

# 对象的相等与指向他们的引用相等，两者有什么不同

对象的相等，比的是内存中存放的内容是否相等，而引用相等，比较的是他们指向内存地址是否相等

# 在调用子类构造方法之前会先调用父类没有参数的构造方法，其目的是

帮助子类做初始化工作

# == 与equals

==是判断变量指的对象的地址相不相等，基本类型指的是值是否相等

equals（）：看情况

1. 类没有覆盖equals方法，则通过equals相当于使用==
2. 类覆盖equals方法，就看内容

# hashcode与equals（为什么重写equals时必须重写hashcode方法）

## hashcode（）介绍

hashcode是为了获取哈希值，也称散列码，实际是一个int整数。哈希码对应的是哈希表的索引的位置，hashcode方法在Object上面，

散列表存储的是键值对（）能根据键快速检索出值

## 为什么要有hashcode

HashSet不允许相等的值出现，当把对象加入HashSet时，先判断是否有相同的hashCode，如果有就调用equals方法比较值是否相等。减少equals的调用加快代码执行速度

## hashcode（）与equals（）的相关规定

1. 如果两个对象相等，则hashcode一定是相同的
2. 两个对象相等，两个对象调用equals方法都返回true
3. 两个对象有相同的hashcode值，他们也不一定相等
4. equals方法被覆盖过，则hashcode方法也必须被覆盖
5. hashcode的默认行为是对堆上的对象产生独特值，如果没有重写hashcode（）则该class的两个对象无论都不会相等

---

## hashcode与equals的联系

这里要分两种情况，1.要用散列表的时候，2.不用散列表的时候

1. 不用散列表的时候，hashcode和equals没关系，hashcode相等，值不一定相等
2. 要用散列表的时候，比如hashset，在hashcode不相等，值却相等的时候，必须重写hashcode方法和equals。

# 为什么java中只有值传递

在java中不管是普通类型的传递还使用引用型的传递，都会把参数进行复制后在进行传递。不会改变原来参数的值或指向。

# 线程跟进程的区别

进程是一次程序运行所产生，进程可以包含很多线程，线程可以共享一块内存空间和一组系统资源

# 线程有哪些基本状态

有6种状态

1. new 初始状态，还没有调用start（）fangfa
2. runnable 运行状态，java线程把就绪和运行两种状态笼统地成为运行中 
3. blocked 阻塞，表示线程阻塞于锁
4. waiting 等待状态，表示线程进入等待状态
5. time_waiting 超时等待状态，该状态不同于waiting，他是可以在指定事件自行返回的
6. terminated 终止状态，表示当前线程已经执行完毕

![Javaçº¿ç¨çç¶æ](Java面试基础知识.assets/Java线程的状态.png)



![Javaçº¿ç¨ç¶æåè¿](Java面试基础知识.assets/Java 线程状态变迁.png)

# 关于final关键字的一些总结

final 关键字主要用在三个地方：变量、方法、类。

1. 在变量中，基本类型不能更改值，引用类型，不能再指向另外一个对象
2. 在类中，这个类不能被继承，类的方法隐式地指定为final方法
3. 在方法中，
   1. 防止方法被修改
   2. 在早期的java实现版中，会把final方法转为内嵌调用，效率会提高，但方法过大，效率不明显，类中的所有的private方法被隐形的指定为final

# java中的异常

![Javaå¼å¸¸ç±»å±æ¬¡ç»æå¾](Java面试基础知识.assets/Exception.png)

Error是程序无法处理的错误，程序员无法处理不用trycatch，比如栈溢出，内存溢出

Exceptional，可以捕获的异常比如除零错误

## Throwable类常用方法

- **public string getMessage()**:返回异常发生时的简要描述
- **public string toString()**:返回异常发生时的详细信息
- **public string getLocalizedMessage()**:返回异常对象的本地化信息。使用 Throwable 的子类覆盖这个方法，可以生成本地化信息。如果子类没有覆盖该方法，则该方法返回的信息与 getMessage（）返回的结果相同
- **public void printStackTrace()**:在控制台上打印 Throwable 对象封装的异常信息

在一线4种情况下，finally块不会被执行

1. 在 finally 语句块第一行发生了异常。 因为在其他行，finally 块还是会得到执行
2. 在前面的代码中用了 System.exit(int)已退出程序。 exit 是带参函数 ；若该语句在异常语句之后，finally 会执行
3. 程序所在的线程死亡。
4. 关闭 CPU。

``` java
 public static int f(int value) {
        try {
            return value * value;
        } finally {
            if (value == 2) {
                return 0;
            }
        }
    }
```

如果调用 `f(2)`，返回值将是 0，因为 finally 语句的返回值覆盖了 try 语句块的返回值。

# java序列化中如果有些字段不想进行序列化，怎么办

对于不想进行序列化的变量，使用transient关键字修饰

![IO-æä½æ¹å¼åç±»](Java面试基础知识.assets/IO-操作方式分类.png)

![IO-æä½å¯¹è±¡åç±»](Java面试基础知识.assets/IO-操作对象分类.png)

# 既然有字节流，为什么还要有字符流

字符流是由java虚拟机将字节转换得到的，问题这过程十分耗时。不知道编码类型的话还会出现错误。

# BIO，NIO，AIO有什么区别

BIO同步阻塞io模式，在活动连接数不是特别高（小于单机1000）

NIO是同步非阻塞的io模型（对于高负载、高并发合适）

AIO就是NIO2在java7中引入NIO的改进版，是异步非阻塞模式

# 常见关键字总结：static，final，this，super

分四种情况

1. 修饰成员变量和成员方法：不属于单个这个类的某个对象，被类中所有对象共享，可以通过类名.静态变量名 ，类名.静态方法名（）
2. 静态代码块，类的执行顺序（静态代码块》非静态代码块》构造方法）该类不管创建多少个对象，静态代码值执行一次
3. 静态内部类（static修饰类的话只能修饰内部类）静态内部类与非静态内部类之间存在一个最大的区别: 非静态内部类在编译完成之后会隐含地保存着一个引用，该引用是指向创建它的外围类，但是静态内部类却没有。没有这个引用就意味着：1. 它的创建是不需要依赖外围类的创建。2. 它不能使用任何外围类的非static成员变量和方法。
4. 静态导包：使用import static 这两个关键字连用可以指定导入某个类中的指定静态资源，



## this关键字

this可以访问当前实例的变量

## super关键字

super可以访问父类的方法和成员变量

注意点：super（）在构造方法中时，要写在第一行，

this、super不能再static方法中，

# static｛｝静态代码块与｛｝非静态代码块（构造代码块）

相同点：都在构造方法之前执行，

不同点：静态代码块在非静态代码块之前执行，静态代码只执行一次（除非用反射）。而非静态代码每new一次就执行一次

# 深拷贝和浅拷贝的区别

如果对象里有引用对象，也想进行拷贝就用深拷贝，如果不想就用浅拷贝

## 区别

深拷贝：对引用对象也进行拷贝，要分别实现cloneable接口

浅拷贝：不对引用对象进行拷贝，只是指向相同的对象。

详细看：

https://www.cnblogs.com/plokmju/p/7357205.html



