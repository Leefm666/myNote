# 什么是线程和进程

## 何为进程

进程是程序的一次执行过程，在java中，当我们启动main函数时其实就是启动了一个jvm的进程，而main函数所在的线程就是这个进程中的一个线程，也称主线程。

如下图所示，

![è¿ç¨ç¤ºä¾å¾ç-Windows](java并发.assets/进程示例图片-Windows.png)

# 何为线程

线程是一个比进程跟小的执行单位，一个进程可以产生多个线程。与进程不同的是多个线程共享进程的队和方法区资源，但每个线程有自己的程序技术器、虚拟机栈和本地方法栈

# 请简要描述线程与进程的关系，区别及优缺点

从jvm角度说进程和进程之间的关系

## 图解进程和线程的关系

![img](java并发.assets/JVM运行时数据区域.png)

从上图可以看出：一个进程中可以有多个线程，多个线程共享进程的**堆**和**方法区 (JDK1.8 之后的元空间)**资源，但是每个线程有自己的**程序计数器**、**虚拟机栈** 和 **本地方法栈**。

**总结：** 线程是进程 划分成的更小的运行单位。线程和进程最大的不同在于基本上各进程是独立的，而各线程则不一定，因为同一进程中的线程极有可能会相互影响。线程执行开销小，但不利于资源的管理和保护；而进程正相反

# 程序计数器为什么是私有的

1. 字节码解释器通过程序计数器来依次读取指令
2. 在多线程的情况下，记录当前线程执行的位置。

需要注意的是，如果执行的是 native 方法，那么程序计数器记录的是 undefined 地址，只有执行的是 Java 代码时程序计数器记录的才是下一条指令的地址。

所以，程序计数器私有主要是为了**线程切换后能恢复到正确的执行位置**。

# 虚拟机栈和本地方法栈为什么是私有的

- **虚拟机栈** 每个java方法在执行的同时会创建一个栈帧用来存储局部变量表、操作数栈、常量池引用等信息

- **本地方法栈：** 和虚拟机栈所发挥的作用非常相似，区别是： **虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。** 在 HotSpot 虚拟机中和 Java 虚拟机栈合二为一。

所以，为了**保证线程中的局部变量不被别的线程访问到**，虚拟机栈和本地方法栈是线程私有的。

# 一句话简单理解堆和方法区

堆和方法区是所有线程共享的资源，其中堆是进程中最大的一块内存，主要用于存放新创建的对象 (所有对象都在这里分配内存)，方法区主要用于存放已被加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。

# 什么是上下文切换

概括来说就是：当前任务在执行完 CPU 时间片切换到另一个任务之前会先保存自己的状态，以便下次再切换回这个任务时，可以再加载这个任务的状态。**任务从保存到再加载的过程就是一次上下文切换**。

# 什么是线程死锁

线程死锁描述的是这样一种情况：多个线程同时被阻塞，它们中的一个或者全部都在等待某个资源被释放。由于线程被无限期地阻塞，因此程序不可能正常终止。

![çº¿ç¨æ­»éç¤ºæå¾ ](java并发.assets/2019-4死锁1.png)

学过操作系统的朋友都知道产生死锁必须具备以下四个条件：

1. 互斥条件：该资源任意一个时刻只由一个线程占用。
2. 请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。
3. 不剥夺条件:线程已获得的资源在末使用完之前不能被其他线程强行剥夺，只有自己使用完毕后才释放资源。
4. 循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系。

# 如何避免线程死锁

我上面说了产生死锁的四个必要条件，为了避免死锁，我们只要破坏产生死锁的四个条件中的其中一个就可以了。现在我们来挨个分析一下：

1. **破坏互斥条件** ：这个条件我们没有办法破坏，因为我们用锁本来就是想让他们互斥的（临界资源需要互斥访问）。
2. **破坏请求与保持条件** ：一次性申请所有的资源。
3. **破坏不剥夺条件** ：占用部分资源的线程进一步申请其他资源时，如果申请不到，可以主动释放它占有的资源。
4. **破坏循环等待条件** ：靠按序申请资源来预防。按某一顺序申请资源，释放资源则反序释放。破坏循环等待条件。

# 说说sleep（）方法和wait（）方法区别和共同点

- 两者最主要的区别在于：**sleep 方法没有释放锁，而 wait 方法释放了锁** 。
- 两者都可以暂停线程的执行。
- Wait 通常被用于线程间交互/通信，sleep 通常被用于暂停执行。
- wait() 方法被调用后，线程不会自动苏醒，需要别的线程调用同一个对象上的 notify() 或者 notifyAll() 方法。sleep() 方法执行完成后，线程会自动苏醒。或者可以使用 wait(long timeout)超时后线程会自动苏醒。

# 为什么我们调用start（）方法时执行run()方法，为什么我们不能直接调用run方法

new 一个thread，线程进入新建状态，调用start（）方法，会启动一个线程并使线程进入了就绪状态，当分配到时间片就开始执行，在执行run方法的内容

